# 약수와 배수 개수 구하기

## 개요
이 알고리즘은 주어진 정수 배열에서 각 숫자에 대해 **나의 약수이거나, 나의 배수인 수가 배열 내에 몇 개 존재하는가**를 구하는 문제입니다.

일반적인 이중 반복문($O(N^2)$)을 사용하지 않고, 시간 복잡도를 줄인 풀이입니다.

## 핵심 원리

이 코드는 다음 네 가지 핵심 철학으로 설계되었습니다.

### 1. 누적
**"개별 숫자의 계산을 끝내고 넘어가는 것이 아니라, 모두가 공유하는 점수판에 그때그때 기록한다."**

* **기존 방식:** 배열의 첫 번째 숫자를 잡고, 그 숫자의 약수와 배수를 전부 세서 저장한 뒤, 다음 숫자로 넘어가는 순차적 처리 방식입니다.
* **이 코드의 방식:**
    * 1부터 최대값까지 숫자를 순회하면서, 약수나 배수 관계가 발견될 때마다 **공용 점수판**의 해당 위치에 점수를 즉시 더해줍니다.
    * 순서와 상관없이 약수/배수 관계가 성립하는 즉시 카운트를 누적합니다.
    * 모든 반복이 끝난 뒤, 점수판에 적힌 최종 점수만 가져가면 됩니다.
    * **의의:** 입력 배열의 순서에 얽매이지 않고, 숫자 자체의 수학적 성질(배수 점프)을 이용해 효율적으로 순회할 수 있습니다.

### 2. 관계의 대칭성
**"배수를 찾으러 갔다가, 약수도 찾고 온다."**

* 수학적으로 $a$가 $b$의 약수이면, 반드시 $b$는 $a$의 배수입니다.
* 배수를 찾기 위해 한 번 순회하고, 약수를 찾기 위해 다시 순회할 필요 없이 **단 한 번의 탐색**으로 두 관계를 동시에 포착하여 처리합니다.

### 3. 점프 탐색
**"1부터 $n$까지 $n$번 순회하는 비효율을 제거합니다."**

* 작은 수에서 큰 수로 이동할 때 1씩 증가하며 모든 수를 훑는 것이 아니라
* **배수 위치로 바로 점프**하여 이동합니다.

### 4. 빈도수 테이블 활용
**"같은 숫자는 여러 번 계산하지 않고 한 번에 처리한다."**

* **문제점:** 만약 입력 배열에 `[2, 2, 2, ...]` 처럼 같은 숫자가 10만 개 들어있다면, 일반적인 방식은 똑같은 연산을 10만 번 반복해야 합니다.
* **해결책:** 미리 `freq` 테이블을 만들어 각 숫자의 등장 횟수를 저장해둡니다. (예: `freq[2] = 100,000`)
* **효과:**
    * 로직은 중복 횟수와 상관없이 숫자 `2`에 대해 **단 한 번만** 수행됩니다.
    * 배수 관계가 확인되면, 반복문을 돌지 않고 `freq` 값을 바로 더해주어 **10만 번 반복해야 할 계산을 단 한 번의 덧셈 연산으로 대체**합니다.

## 시간 복잡도 상세 분석

이 알고리즘의 최종 시간 복잡도는 **$O(N + M \log M)$** 입니다.

* **$N$**: 입력 데이터의 개수
* **$M$**: 입력 데이터 중 가장 큰 값

### 복잡도 유도 과정

1. **빈도수 테이블 생성:** $O(N)$
2. **배수/약수 관계 찾기:**
    * 이 과정은 **조화 급수(Harmonic Series)** 형태를 띱니다.
    * $\frac{M}{1} + \frac{M}{2} + \frac{M}{3} + \dots + \frac{M}{M} = M(1 + \frac{1}{2} + \dots + \frac{1}{M})$
    * 괄호 안의 식은 수학적으로 자연로그($\ln M$)에 수렴합니다.
    * 따라서 비용은 **$O(M \log M)$** 입니다.
3. **결과 매핑:** $O(N)$

### 최종 합산
$$O(N) + O(M \log M) + O(N) \approx O(N + M \log M)$$